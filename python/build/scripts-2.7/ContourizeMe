#!/usr/bin/python2

from Tkinter import *
import matplotlib.pyplot as plt
import tkFileDialog
import cv2
import numpy as np
import logging
import argparse
from PIL import ImageTk, Image
import sys
import copy
from skimage.io import imread
from scipy.interpolate import insert
from numpy import asarray, unique, split, sum
from scipy import interpolate
from svgpathtools import CubicBezier, wsvg
from scipy.spatial import KDTree
import pandas as pd

from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg, NavigationToolbar2TkAgg
from matplotlib.backend_bases import MouseEvent
from matplotlib.figure import Figure

from scipy.stats import norm

def image2pixelarray(filepath):
    """
    Parameters
    ----------
    filepath : str
        Path to an image file

    Returns
    -------
    list
        A list of lists which make it simple to access the greyscale value by
        im[y][x]
    """
    im = Image.open(filepath).convert('L')
    (width, height) = im.size
    greyscale_map = list(im.getdata())
    greyscale_map = np.array(greyscale_map)
    greyscale_map = greyscale_map.reshape((height, width))
    return greyscale_map

def get_beziers(tck, per = True):
    """Convert a parametric b-spline into a sequence of Bezier curves of the same degree.

    Inputs:
    tck : (t,c,k) tuple of b-spline knots, coefficients, and degree returned by splprep.
    per : if tck was created as a periodic spline, per *must* be true, else per *must* be false.

    Output:
    A list of Bezier curves of degree k that is equivalent to the input spline. 
    Each Bezier curve is an array of shape (k+1,d) where d is the dimension of the
    space; thus the curve includes the starting point, the k-1 internal control 
    points, and the endpoint, where each point is of d dimensions.
    """
    t,c,k = tck
    t = asarray(t)
    try:
        c[0][0]
    except:
        # I can't figure out a simple way to convert nonparametric splines to 
        # parametric splines. Oh well.
        raise TypeError("Only parametric b-splines are supported.")
    new_tck = tck
    if per:
        # ignore the leading and trailing k knots that exist to enforce periodicity 
        knots_to_consider = unique(t[k:-k])
    else:
        # the first and last k+1 knots are identical in the non-periodic case, so
        # no need to consider them when increasing the knot multiplicities below
        knots_to_consider = unique(t[k+1:-k-1])
    # For each unique knot, bring it's multiplicity up to the next multiple of k+1
    # This removes all continuity constraints between each of the original knots, 
    # creating a set of independent Bezier curves.
    desired_multiplicity = k+1
    for x in knots_to_consider:
        current_multiplicity = sum(t == x)
        remainder = current_multiplicity%desired_multiplicity
    if remainder != 0:
        # add enough knots to bring the current multiplicity up to the desired multiplicity
        number_to_insert = desired_multiplicity - remainder
        new_tck = insert(x, new_tck, number_to_insert, per)
    tt,cc,kk = new_tck
    # strip off the last k+1 knots, as they are redundant after knot insertion
    bezier_points = np.transpose(cc)[:-desired_multiplicity]
    if per:
        # again, ignore the leading and trailing k knots
        bezier_points = bezier_points[k:-k]
    # group the points into the desired bezier curves
    return np.array_split(bezier_points, len(bezier_points) / desired_multiplicity, axis = 0)

"""
Creates a Tkinter interface that allows one to pick a 8-bit pixel value for the
thresholding mask.

Takes either an image or reads the first frame from a movie.
"""

def map_uint16_to_uint8(img, lower_bound=None, upper_bound=None):
    '''
    Map a 16-bit image trough a lookup table to convert it to 8-bit.

    Parameters
    ----------
    img: numpy.ndarray[np.uint16]
        image that should be mapped
    lower_bound: int, optional
        lower bound of the range that should be mapped to ``[0, 255]``,
        value must be in the range ``[0, 65535]`` and smaller than `upper_bound`
        (defaults to ``numpy.min(img)``)
    upper_bound: int, optional
       upper bound of the range that should be mapped to ``[0, 255]``,
       value must be in the range ``[0, 65535]`` and larger than `lower_bound`
       (defaults to ``numpy.max(img)``)

    Returns
    -------
    numpy.ndarray[uint8]
    '''
    if not(0 <= lower_bound < 2**16) and lower_bound is not None:
        raise ValueError(
            '"lower_bound" must be in the range [0, 65535]')
    if not(0 <= upper_bound < 2**16) and upper_bound is not None:
        raise ValueError(
            '"upper_bound" must be in the range [0, 65535]')
    if lower_bound is None:
        lower_bound = np.min(img)
    if upper_bound is None:
        upper_bound = np.max(img)
    if lower_bound >= upper_bound:
        raise ValueError(
            '"lower_bound" must be smaller than "upper_bound"')
    lut = np.concatenate([
        np.zeros(lower_bound, dtype=np.uint16),
        np.linspace(0, 255, upper_bound - lower_bound).astype(np.uint16),
        np.ones(2**16 - upper_bound, dtype=np.uint16) * 255
    ])
    return lut[img].astype(np.uint8)

contours = None
imgray = None

from scipy.optimize import minimize
from scipy.spatial.distance import euclidean
import progressbar

beziers = None
outs = None
tcks = []
pp = 5

t1 = None


def brightness(dd, out):
    out[np.where((out[:,0].astype(np.int32) > imgray.shape[1] - 1) | (out[:,1].astype(np.int32) > imgray.shape[0] - 1))] = np.zeros(2)
    
    vals = np.array([imgray[int(np.floor(uv[1])) - 1, int(np.floor(uv[0])) - 1] for uv in out], dtype = np.float32)

    maxx = np.max(out[:,0])
    maxy = np.max(out[:,1])
    minx = np.min(out[:,0])
    miny = np.min(out[:,1])
    
    counts = np.zeros(vals.shape)

    for dp in np.linspace(0.1, 5., 6):
        to_move = dd*dp
        nout = to_move + out

        i = np.where((nout[:,0].astype(np.int32) > imgray.shape[1] - 1) | (nout[:,1].astype(np.int32) > imgray.shape[0] - 1))
        nout[i] = np.array([np.nan, np.nan])
        _ = np.zeros(vals.shape)
        _[list(set(range(len(vals))).difference(i[0]))] = np.array([imgray[int(uv[1]), int(uv[0])] for uv in nout if not np.isnan(uv[0])])


        #print _
        counts[np.where((nout[:,0].astype(np.int32) < imgray.shape[1] - 1) | (nout[:,1].astype(np.int32) < imgray.shape[0] - 1))] += 1.
        
        vals += _.astype(np.float32)

    i = np.where(counts != 0.)
    vals[i] = vals[i] / counts
    vals[np.where((out[:,0] < minx + 10) | (out[:,1] > maxx - 5))] = np.nan
    
    return vals

def cubic_smooth_bezier(p, t, d = 0):
    if d == 0:
        return (1. - t)**3*p[0]  + 3.*(1. - t)**2*t*p[0] + 3*(1. - t)*t**2*p[1] + t**3*p[2]
    elif d == 1:
        return 6.*(1. - t)*t*(p[1] - p[0]) + 3.*t**2*(p[2] - p[1])
    elif d == 2:
        return 6.*(1. - t)*(p[1] - 2.*p[0] + p[0]) + 6.*t*(p[2] - 2.*p[1] + p[0])
        
def get_rets(contours, pt):
    rets = []
    for c in contours:
        rets.append(cv2.pointPolygonTest(c, tuple(pt), False))

    return rets

def save_to_svg():
    plt.clf()
    if len(contours) > 0:
        filename = tkFileDialog.asksaveasfilename()
        diameters = []

        dataf = dict()
        dataf['diameter'] = list()
        dataf['x_midpoint'] = list()
        dataf['y_midpoint'] = list()

        plot_beziers(plot = False)

        print('Computing normal vectors and diameter...')
        nvs = []
        xys = []
        
        dd = []
        _ = []
        
        for b in beziers:
            _.append(cubic_smooth_bezier(b, 0.5))
            v = cubic_smooth_bezier(b, 0.5, d = 1)
            dd.append([-v[1], v[0]])
                
        dd = np.array(dd)
        norm = np.sqrt(np.sum(np.power(dd, 2), axis = 1))

        # both directions
        dd = dd / np.hstack((np.reshape(norm, (len(norm), 1)), np.reshape(norm, (len(norm), 1))))
        ndd = -dd

        vals1 = brightness(dd, np.array(_))
        vals2 = brightness(ndd, np.array(_))

        vals = np.vstack((vals1, vals2))
        indices = np.where((np.isnan(vals1) == False) & (np.isnan(vals1) == False))[0]
                
        maxs = np.nanargmax(vals[:,indices], axis = 0)

        for i in range(len(indices)):
        
            if maxs[i] == 0:
                nvs.append(dd[indices[i]])
            else:
                nvs.append(ndd[indices[i]])
            xys.append(_[indices[i]])

            
        nvs = np.array(nvs)
        xys = np.array(xys)

        mouts = contours[0]

        for i in range(1, len(contours)):
            mouts = np.vstack((mouts, contours[i]))

        mouts = mouts.reshape((len(mouts), 2))

        bar = progressbar.ProgressBar()
        si = []
            
        #print len(tcks)
        for i in range(len(nvs)):
            nv = nvs[i]
            xy = xys[i]
            #print xy
            xy = np.tile(xy, (len(mouts), 1))

            dirs = mouts - xy
            norm = np.sqrt(np.sum(np.power(dirs, 2), axis = 1))

            dirs = dirs / np.hstack((np.reshape(norm, (len(norm), 1)), np.reshape(norm, (len(norm), 1))))
            
            _ = np.tile(nv, (len(mouts), 1))
            dots = np.sum(dirs*_, axis = 1)
            dots = np.arccos(dots)

            eligible = mouts[np.where((dots < np.pi*(3. / 180.)))[0]]
            eligible = eligible.astype(np.float32)
            
            if eligible.shape[0] != 0:
                tree = KDTree(eligible)

                d, index = tree.query(xy[0])
                diameters.append(d)
                #print d
                si.append(i)
            
            
            
        
            
            
        paths = []
        for b in beziers:
            x1, y1 = b[0]
            if (5. < x1 < im.shape[1] - 5) and (5. < y1 < im.shape[0]):
                cx2, cy2 = b[1]
                x2, y2 = b[2]
                paths.append(CubicBezier(x1 + 1j * y1, x1 + 1j * y1, cx2 + 1j * cy2, x2 + 1j * y2))

        print('Writing SVG file...')
        #print len(paths)
        wsvg(paths, filename = filename + '.svg')

        print('Plotting diameter visualization...')
        for out in outs:
            plt.plot(out.T[:,0], out.T[:,1], c = 'r')

        for k in si:
            x1, y1 = xys[k]
            x2, y2 = xys[k] + nvs[k]*diameters[si.index(k)]
            xm, ym = xys[k] + nvs[k]*diameters[si.index(k)]*0.5

            rets = get_rets(contours, np.array([xm,ym]))

            if True in rets:
                dataf['diameter'].append(diameters[si.index(k)])
                dataf['x_midpoint'].append(xm)
                dataf['y_midpoint'].append(ym)
                
                plt.plot([x1, x2], [y1, y2], c = 'b')

        dataf = pd.DataFrame(dataf)
        dataf.to_csv(filename + '-diameters.csv', index = False)

        plt.savefig(filename + '-diameters.png', dpi = 100)
        print('Done!')

def plot_beziers(plot = True, ofile = None):
    plt.clf()
    print('Creating bezier curves...')
    global beziers
    global outs

    outs = []
    beziers = []

    for c in contours:
        perimeter = cv2.arcLength(c,True)
        c = np.reshape(c, (len(c), 2)).astype(np.float32)
        #print c.shape
        c = np.append(c, c[0].reshape(1, 2), axis = 0)

        #points.extend([u for u in c])
        
        x = c[:,0]
        y = c[:,1]

        tck,u = interpolate.splprep([x,y], per = len(c))
        tcks.append(tck)

        unew = np.linspace(0., 1., int(np.round(perimeter / pp)) * 2 + 1)

        out = interpolate.splev(unew,tck)
        out = np.array(out)

        outs.append(out)

        for k in range(out.shape[1] / 2):
            b = out[:,2*k:2*(k + 1) + 1].T
            beziers.append(b)

        if plot:
            print('Plotting...')

            for b in beziers:
                t = np.linspace(0., 1., 6)
                xy = np.array([cubic_smooth_bezier(b, u) for u in t])

                plt.plot(xy[:,0], xy[:,1], c = 'b')

            plt.show()
            plt.close()
            
if __name__ == '__main__':
    parser = argparse.ArgumentParser(description="allows the user to slide to a values for 8-bit pixel thresholding")
    parser.add_argument("--movie", default = "None")
    parser.add_argument("--image", default = "None")
    parser.add_argument("--scale", default = "0.5")

    args = parser.parse_args()

    if args.movie == "None" and args.image == "None":
        print("No movie or image specified! Use --image or --movie argument")
        sys.exit()

    if args.movie != "None":
        mov = cv2.VideoCapture(args.movie)
        im = mov.read()
    else:
        im = cv2.imread(args.image)

    print 'Working with image of size {0} x {1}'.format(im.shape[1], im.shape[0])

    scale = float(args.scale)
    #print im

    samples = dict()
    samples['In'] = dict()
    samples['Out'] = dict()
    
    samples['In']['RGB'] = list()
    samples['In']['HSV'] = list()
    samples['In']['Grayscale'] = list()

    samples['Out']['RGB'] = list()
    samples['Out']['HSV'] = list()
    samples['Out']['Grayscale'] = list()

    if im is None:
        # read with the alternate method
        im = imread(args.image)
        # print '16-bit image detected'
        # convert the image array to 8-bit grayscale
        # imgray = im.astype(np.uint8)
        
        imgray = map_uint16_to_uint8(im)
        im = cv2.cvtColor(imgray, cv2.COLOR_GRAY2BGR)
    elif len(im.shape) == 3:
        #print '8-bit image detected'
        imgray = cv2.cvtColor(im,cv2.COLOR_BGR2GRAY)
    else:
        imgray = im
        
    mim = cv2.cvtColor(copy.copy(im), cv2.COLOR_BGR2RGB)
    # BGR = im

    # HSV = hsv_im
    hsv_im = cv2.cvtColor(im, cv2.COLOR_BGR2HSV)
    
    #imgray = cv2.cvtColor(im,cv2.COLOR_BGR2GRAY)
    # threshold 
    ret,thresh = cv2.threshold(imgray,127,255,0)
    _ = cv2.findContours(thresh,cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE)

    if len(_) == 3:
        _, contours, hierarchy = _
    else:
        contours, hierarchy = _
    
    contours = sorted(contours, key = len, reverse = True)
    #im = cv2.imread(os.path.join(args.idir, image))
    for j in range(1):
        cv2.drawContours(mim, contours, j, color=(0,0,0), thickness=-1)

    bounds = np.zeros((3,6))

    def take_in_sample(event):
        global samples
        
        canvas = event.widget
        x = canvas.canvasx(event.x)
        y = canvas.canvasy(event.y)

        
        samples['In'][pamVar.get()].append(imgray[int(y/scale), int(x/scale)])

        update_norms(pamVar.get())

        callback(event)

    def take_out_sample(event):
        global samples
        
        canvas = event.widget
        x = canvas.canvasx(event.x)
        y = canvas.canvasy(event.y)

        samples['Out'][pamVar.get()].append(imgray[int(y/scale), int(x/scale)])

        update_norms(pamVar.get())

        callback(event)

        callback(event)

    def clear_sample(event):
        samples = dict()
        samples['In'] = dict()
        samples['Out'] = dict()
        
        samples['In']['RGB'] = list()
        samples['In']['HSV'] = list()
        samples['In']['Grayscale'] = list()

        samples['Out']['RGB'] = list()
        samples['Out']['HSV'] = list()
        samples['Out']['Grayscale'] = list()

        print 'Cleared...'

    def update_norms(mode):
        global bounds

        if mode == 'Grayscale':
            if len(samples['In']['Grayscale']) > 5:
                mu = np.mean(np.array(samples['In']['Grayscale']))
                std = np.std(np.array(samples['In']['Grayscale']))

                z = -norm.ppf((1. - float(normalBound.get())/100.) / 2.)
                bounds[0,[0,3]] = [mu - z*std, mu + z*std]
        elif mode == 'RGB':
            if len(samples['In']['RGB']) > 5:
                mu = np.mean(np.array(samples['In']['RGB']), axis = 0)
                std = np.std(np.array(samples['In']['RGB']), axis = 0)

                z = -norm.ppf((1. - float(normalBound.get())/100.) / 2.)
                bounds[1,:3] = mu - z*std
                bounds[1,3:] = mu + z*std

        elif mode == 'HSV':
            if len(samples['In']['HSV']) > 5:
                mu = np.mean(np.array(samples['In']['HSV']), axis = 0)
                std = np.std(np.array(samples['In']['HSV']), axis = 0)

                z = -norm.ppf((1. - float(normalBound.get())/100.) / 2.)
                bounds[2,:3] = mu - z*std
                bounds[2,3:] = mu + z*std

            

        #print bounds
            
        
    root = Tk()
    root.resizable(width=False, height=False)
    img = Image.fromarray(cv2.resize(mim, (0,0), fx = scale, fy = scale))
    img = ImageTk.PhotoImage(img)
    
    panel = Canvas(root, width = im.shape[1] * scale, height = im.shape[0] * scale)
    panel.grid(row = 0, column = 0, rowspan = 5, columnspan = 6, sticky = 'W')
    i = panel.create_image((im.shape[1] * (scale / 2.), im.shape[0] * (scale / 2.)), image = img)

    panel.tag_bind(i, '<ButtonPress-1>', take_in_sample)
    panel.tag_bind(i, '<Control-1>', take_out_sample)
    root.bind('<Control-c>', clear_sample)

    def quit_all():
        root.quit()
        root.destroy()
        plt.close()
        sys.exit()
        
    def callback(e = None):
        global contours
        global pp
        global t1
        global panel
        global i

        mim = cv2.cvtColor(copy.copy(im), cv2.COLOR_BGR2RGB)

        pp = float(w4.get())

        if blurVar.get() == 1:
            try:
                if pamVar.get() == 'Grayscale':
                    tothresh = cv2.blur(imgray, (int(kernelSize.get()), int(kernelSize.get())))
                    ix = 0
                elif pamVar.get() == 'RGB':
                    tothresh = cv2.blur(im, (int(kernelSize.get()), int(kernelSize.get())))
                    ix = 1
                elif pamVar.get() == 'HSV':
                    tothresh = cv2.blur(hsv_im, (int(kernelSize.get()), int(kernelSize.get())))
                    ix = 2
                mim = cv2.blur(mim, (int(kernelSize.get()), int(kernelSize.get())))
            except:
                pass
        else:
            if pamVar.get() == 'Grayscale':
                tothresh = imgray
                ix = 0
            elif pamVar.get() == 'RGB':
                tothresh = im
                ix = 1
            elif pamVar.get() == 'HSV':
                tothresh = hsv_im
                ix = 2
        
        
        r1 = int(np.round(w1.get()))
        r2 = int(np.round(w2.get()))

        b1 = int(np.round(w5.get()))
        b2 = int(np.round(w6.get()))

        g1 = int(np.round(w7.get()))
        g2 = int(np.round(w8.get()))
        
        if methodVar.get() == 'Normal distribution':
            bounds[np.where(bounds > 255)] = 255.
            bounds[np.where(bounds < 0)] = 0.
            if len(samples['In'][pamVar.get()]) > 5:
                r1, g1, b1, r2, g2, b2 = np.round(bounds[ix])
                
        #print r1, r2, b1, b2, g1, g2

        try:
            if pamVar.get() == 'Grayscale':
                ret,thresh = cv2.threshold(tothresh,r1,r2,0)
            elif pamVar.get() == 'RGB':
                thresh = cv2.inRange(tothresh, (b1, g1, r1), (b2, g2, r2))
            elif pamVar.get() == 'HSV':
                thresh = cv2.inRange(tothresh, (r1, g1, b1), (r2, g2, b2))  

            _ = cv2.findContours(thresh,cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE)

            if len(_) == 3:
                _, contours, hierarchy = _
            else:
                contours, hierarchy = _            
            contours = sorted(contours, key = len, reverse = True)
            #im = cv2.imread(os.path.join(args.idir, image))
            if len(contours) > int(np.round(w3.get())):
                contours = contours[:int(np.round(w3.get()))]
            
            cv2.drawContours(mim, contours, -1, color=(0,255,0), thickness=3)

            img = Image.fromarray(cv2.resize(mim, (0,0), fx = scale, fy = scale))
            img = ImageTk.PhotoImage(img)

            panel.itemconfig(i, image = img)
            panel.image = img
        except:
            pass

            

    # export as SVG
    # no smoothing for now
    # compute diameter from data

    blurVar = IntVar()
    kernelSize = StringVar()
    kernelSize.set('5')
    methodVar = StringVar()
    methodVar.set('Manual')

    normalBound = StringVar()
    normalBound.set('95')

    pamVar = StringVar()
    pamVar.set('Grayscale')

    C = StringVar()
    C.set(1.0)

    gamma = StringVar()
    gamma.set(1.0)
    
    kernelSize.trace("w", lambda name, index, mode, kernelSize=kernelSize: callback(kernelSize))
     
    root.protocol('WM_DELETE_WINDOW', quit_all)

    group = LabelFrame(root, text="Settings", padx=5, pady=5,  fg = '#56A0D3')
    group.grid(row = 7, column = 6, rowspan = 4, sticky = 'NSEW', columnspan  = 6, padx = 10, pady = 10)
    
    w1 = Scale(root, from_=0, to=255, orient=VERTICAL, command = callback)
    w1.set(100)
    w1.grid(row = 0, column = 6, padx = 10, pady = 5, rowspan = 6, sticky = 'NS')
    w2 = Scale(root, from_=0, to=255, orient=VERTICAL, command = callback)
    w2.set(255)
    w2.grid(row = 0, column = 7,  padx = 10, pady = 5, rowspan = 6, sticky = 'NS')

    w5 = Scale(root, from_=0, to=255, orient=VERTICAL, command = callback)
    w5.set(100)
    w5.grid(row = 0, column = 8, padx = 10, pady = 5, rowspan = 6, sticky = 'NS')
    w6 = Scale(root, from_=0, to=255, orient=VERTICAL, command = callback)
    w6.set(255)
    w6.grid(row = 0, column = 9,  padx = 10, pady = 5, rowspan = 6, sticky = 'NS')

    w7 = Scale(root, from_=0, to=255, orient=VERTICAL, command = callback)
    w7.set(100)
    w7.grid(row = 0, column = 10, padx = 10, pady = 5, rowspan = 6, sticky = 'NS')
    w8 = Scale(root, from_=0, to=255, orient=VERTICAL, command = callback)
    w8.set(255)
    w8.grid(row = 0, column = 11,  padx = 10, pady = 5, rowspan = 6, sticky = 'NS')

    Label(root, text = 'Number of contours to show:').grid(row = 5, padx = 10)
    w3 = Scale(root, from_=1, to=10, orient=HORIZONTAL, command = callback)
    w3.set(1)
    w3.grid(row = 6, padx = 10, pady = 5, sticky = 'EW', columnspan = 6)

    Label(root, text = 'Perimeter per Bezier (higher = smoother):').grid(row = 7, padx = 10)
    w4 = Scale(root, from_=5, to=300, orient=HORIZONTAL, command = callback)
    w4.set(15)
    w4.grid(row = 8, padx = 10, pady = 5, sticky = 'EW', columnspan = 6)

    C1 = Checkbutton(root, text = "Blur with kernel size:", variable = blurVar, \
                 onvalue = 1, offvalue = 0, command = callback).grid(row = 9, padx = 10, sticky = 'W')
    
    Entry(root, textvariable = kernelSize, width = 5).grid(row = 9, padx = 175, sticky = 'W')

    Label(group, text = 'Normal confidence bound (0 to 100):').grid(row = 0, column = 0, padx = 5, pady = 5, sticky = 'W')
    Entry(group, textvariable = normalBound, width = 5).grid(row = 0, column = 1, padx = 5, pady = 5, sticky = 'W')

    Label(group, text = 'C:').grid(row = 1, column = 0, padx = 5, pady = 5, sticky = 'W')
    Entry(group, textvariable = C, width = 5).grid(row = 1, column = 1, padx = 5, pady = 5, sticky = 'W')

    Label(group, text = 'Gamma:').grid(row = 2, column = 0, padx = 5, pady = 5, sticky = 'W')
    Entry(group, textvariable = gamma, width = 5).grid(row = 2, column = 1, padx = 5, pady = 5, sticky = 'W')

    svc = Button(group, text = "Compute SVC", command = save_to_svg)
    svc.grid(column = 2, row = 0, padx = 10, pady = 5, sticky = 'NSEW', rowspan = 3)

    svc_grid = Button(group, text = "Compute SVC with gridsearch", command = save_to_svg)
    svc_grid.grid(column = 3, row = 0, padx = 10, pady = 5, sticky = 'NSEW', rowspan = 3)

    Label(root, text = 'Parameterization:').grid(row = 6, column = 6, padx = 10, pady = 10, sticky = 'W', columnspan = 6)
    method = OptionMenu(root, pamVar, 'Grayscale', 'RGB', 'HSV', command = callback)
    method.grid(row = 6, column = 6, padx = 150, pady = 10, sticky = 'W', columnspan = 6)

    Label(root, text = 'Thresholding method:').grid(row = 6, column = 6, padx = 125, pady = 10, sticky = 'E', columnspan = 6)
    method = OptionMenu(root, methodVar, 'Manual', 'Normal distribution', 'SVC')
    method.grid(row = 6, column = 6, padx = 10, pady = 10, columnspan = 6, sticky = 'E')
    
    save = Button(root, text = "Save to SVG", command = save_to_svg)
    save.grid(row = 10, padx = 10, pady = 5, sticky = 'W')

    save = Button(root, text = "Plot", command = plot_beziers)
    save.grid(row = 10, column = 5, padx = 10, pady = 5, sticky = 'E')

    root.mainloop()
